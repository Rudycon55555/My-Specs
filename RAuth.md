<h1><strong>RAuth (Rudra Authentication) vs. Traditional 2FA (TOTP): A Technical Comparison</strong></h1><p></p><p>This document outlines the conceptual design of <strong>RAuth </strong>(which is MFA), a local-first authentication framework proposed by Rudra, and compares it to the widely used <strong>Time‑based One‑Time Password (TOTP)</strong> 2FA standard. The goal is to highlight architectural differences, security properties, and user‑controlled features.</p><p></p><h1><strong>1. Overview</strong></h1><p></p><h3><strong>Traditional 2FA (TOTP)</strong></h3><p></p><p>TOTP is a shared-secret authentication method where both the server and the user’s device generate a 6‑digit code based on a synchronized clock. The server verifies the code during login.</p><p></p><h3><strong>RAuth (Proposed System)</strong></h3><p></p><p>RAuth is a <strong>local authority authentication system</strong> where the user’s device becomes the primary verifier. Websites request authentication through a <strong>local WebSocket channel</strong>, and the RAuth app enforces customizable, multi-layered security checks before approving access.</p><p></p><h1><strong>2. Core Architectural Differences</strong></h1><p></p><h3><strong>2.1 Where Authentication Logic Lives</strong></h3><p></p><ul><li><p><strong>TOTP:</strong></p><p></p><ul><li><p>Verification happens on the <strong>server</strong>.</p><p></p></li><li><p>The device only generates a code; it does not decide whether login is allowed.</p><p></p></li></ul><p></p></li><li><p><strong>RAuth:</strong></p><p></p><ul><li><p>Verification happens <strong>entirely on the user’s device</strong>.</p><p></p></li><li><p>The website only receives a final “OK” or “Nope” from the local app.</p><p></p></li><li><p>The server never sees passwords, biometrics, or other sensitive factors.</p><p></p></li></ul><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth reduces trust in remote servers and shifts control to the user’s device.</p><p></p><h1><strong>3. Communication Model</strong></h1><p></p><h3><strong>3.1 TOTP</strong></h3><p></p><ul><li><p>No direct communication between device and website.</p><p></p></li><li><p>User manually transfers the 6‑digit code.</p><p></p></li><li><p>The server must implement rate limiting, lockouts, and timing windows.</p><p></p></li></ul><p></p><h3><strong>3.2 RAuth</strong></h3><p></p><ul><li><p>Website connects to a <strong>local WebSocket</strong> (e.g., <code>ws://localhost:8080/authentication/RAuthMFA</code>)</p><p></p></li><li><p>The user’s app:</p><p></p><ul><li><p>Generates a <strong>short-lived session key</strong> (Base32, 30 seconds).</p><p></p></li><li><p>Accepts or rejects the website’s connection attempt.</p><p></p></li><li><p>Performs all security checks locally.</p><p></p></li><li><p>Sends a final “OK” only if all checks pass.</p><p></p></li></ul><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth creates a secure, ephemeral, device-controlled handshake that TOTP does not have.</p><p></p><h1><strong>4. Protection Against Phishing and Origin Spoofing</strong></h1><p></p><h3><strong>TOTP Weakness</strong></h3><p></p><ul><li><p>The authenticator app does not know <strong>which website</strong> is asking for the code.</p><p></p></li><li><p>A phishing site can request a valid TOTP code and immediately use it.</p><p></p></li></ul><p></p><h3><strong>RAuth Strength</strong></h3><p></p><ul><li><p>The user explicitly selects the website in the RAuth app.</p><p></p></li><li><p>If a different site tries to connect:</p><p></p><ul><li><p>The app <strong>rejects</strong> the WebSocket connection.</p><p></p></li><li><p>No authentication attempt proceeds.</p><p></p></li></ul><p></p></li><li><p>This creates <strong>origin-aware authentication</strong>, something TOTP lacks.</p><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth inherently blocks phishing attempts that rely on tricking users into entering codes.</p><p></p><h1><strong>5. Secret and Key Handling</strong></h1><p></p><h3><strong>TOTP</strong></h3><p></p><ul><li><p>Uses a long-term shared secret (Base32-encoded).</p><p></p></li><li><p>If the secret leaks, attackers can generate valid codes forever.</p><p></p></li><li><p>The 6‑digit code is short and must rely on server-side rate limiting.</p><p></p></li></ul><p></p><h3><strong>RAuth</strong></h3><p></p><ul><li><p>Uses <strong>short-lived session keys</strong> generated per authentication attempt.</p><p></p></li><li><p>Keys expire in ~30 seconds and cannot be reused.</p><p></p></li><li><p>No long-term shared secret is required.</p><p></p></li><li><p>The website never receives sensitive data — only the temporary key and final “OK.”</p><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth eliminates long-term secret exposure and reduces brute-force feasibility.</p><p></p><h1><strong>6. Customizable Security Layers</strong></h1><p></p><h3><strong>TOTP</strong></h3><p></p><ul><li><p>Fixed design:</p><p></p><ul><li><p>One factor: the 6‑digit code.</p><p></p></li><li><p>No built-in support for additional checks.</p><p></p></li><li><p>No user-defined security policies.</p><p></p></li></ul><p></p></li></ul><p></p><h3><strong>RAuth</strong></h3><p></p><ul><li><p>User can add <strong>any number of custom security measures</strong>, including:</p><p></p><ul><li><p><strong>Passwords</strong></p><p></p></li><li><p><strong>Biometrics</strong></p><p></p></li><li><p><strong>QR codes</strong></p><p></p></li><li><p><strong>Barcodes</strong></p><p></p></li><li><p><strong>Puzzles</strong></p><p></p></li><li><p><strong>Challenges</strong></p><p></p></li><li><p><strong>Multi-step flows</strong></p><p></p></li><li><p><strong>Custom logic per website</strong></p><p></p></li></ul><p></p></li><li><p>Policies can be:</p><p></p><ul><li><p>“Require ALL of these”</p><p></p></li><li><p>“Require ANY 2 of these 3”</p><p></p></li><li><p>“Lock out after 5 failures”</p><p></p></li><li><p>“Cooldown for 10 minutes after repeated attempts”</p><p></p></li></ul><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth becomes a <strong>user-defined security engine</strong>, not a fixed-factor system.</p><p></p><h1><strong>7. Rate Limiting and Abuse Prevention</strong></h1><p></p><h3><strong>TOTP</strong></h3><p></p><ul><li><p>Server must implement:</p><p></p><ul><li><p>Rate limiting</p><p></p></li><li><p>Lockouts</p><p></p></li><li><p>Timing windows</p><p></p></li><li><p>Replay protection</p><p></p></li></ul><p></p></li></ul><p></p><p>If the server is poorly implemented, security suffers.</p><p></p><h3><strong>RAuth</strong></h3><p></p><ul><li><p>The <strong>local app</strong> enforces:</p><p></p><ul><li><p>Per-website failure limits</p><p></p></li><li><p>Cooldown periods</p><p></p></li><li><p>Immediate WebSocket termination on mismatch</p><p></p></li><li><p>Global abuse detection (e.g., too many attempts across sites)</p><p></p></li></ul><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth ensures consistent security even if websites are poorly coded.</p><p></p><h1><strong>8. Attack Surface Comparison</strong></h1><p></p><h3><strong>TOTP Attack Surfaces</strong></h3><p></p><ul><li><p>Phishing</p><p></p></li><li><p>Secret key leakage</p><p></p></li><li><p>Server-side implementation bugs</p><p></p></li><li><p>Brute-force attempts (mitigated by server rate limits)</p><p></p></li><li><p>User entering codes into malicious sites</p><p></p></li></ul><p></p><h3><strong>RAuth Attack Surfaces</strong></h3><p></p><ul><li><p>Local malware targeting the RAuth app</p><p></p></li><li><p>Misconfigured local policies</p><p></p></li><li><p>Browser restrictions on <a target="_blank" rel="noopener noreferrer nofollow" href="http://localhost">localhost</a> WebSockets</p><p></p></li><li><p>Need for secure identification of website origins</p><p></p></li></ul><p></p><p><strong>Implication:</strong> <br>RAuth shifts risk from remote servers to the local device, which can be both safer and more controllable.</p><p></p><h1><strong>9. Summary of Key Differences</strong></h1><p></p><h3><strong>TOTP</strong></h3><p></p><ul><li><p>Server-controlled</p><p></p></li><li><p>Shared secret</p><p></p></li><li><p>User enters short codes</p><p></p></li><li><p>Vulnerable to phishing</p><p></p></li><li><p>Limited to one factor</p><p></p></li><li><p>Security depends on server implementation</p><p></p></li></ul><p></p><h3><strong>RAuth</strong></h3><p></p><ul><li><p>Device-controlled</p><p></p></li><li><p>Short-lived session keys</p><p></p></li><li><p>Local WebSocket handshake</p><p></p></li><li><p>Rejects unknown websites</p><p></p></li><li><p>Unlimited custom security layers</p><p></p></li><li><p>Consistent local enforcement</p><p></p></li><li><p>Strong phishing resistance</p><p></p></li><li><p>No long-term secrets exposed</p><p></p></li></ul><p></p><h1><strong>10. Conclusion</strong></h1><p></p><p>RAuth represents a <strong>local-first, user-controlled authentication model</strong> that addresses several weaknesses in traditional TOTP-based 2FA:</p><p></p><ul><li><p>It prevents phishing by binding authentication to a specific website.</p><p></p></li><li><p>It eliminates long-term shared secrets.</p><p></p></li><li><p>It allows unlimited, customizable security layers.</p><p></p></li><li><p>It enforces strict local rate limiting and lockouts.</p><p></p></li><li><p>It shifts trust away from remote servers and toward the user’s device.</p><p></p></li></ul><p></p><p>While RAuth would require careful design around usability, origin verification, and local security, the conceptual model is strong and aligns with modern trends in authentication (e.g., WebAuthn, hardware tokens), but with far more user control.</p><hr><h2>Bonus: Flow</h2><p>Here are the steps that it uses:</p><p></p><ol><li><p>Website asks for login via RAuth and displays the "30-Second Key Typing Here" text box.</p></li><li><p>User opens RAuth app locally.</p></li><li><p>User presses "Start" on RAuth app to start the ws://localhost:8080/authentication/RAuthMFA WebSocket (which has a "Stop" button at any time to close the WebSocket; if you fail 5 times in a row, a timeout happens).</p></li><li><p>RAuth app asks which site needs to be authenticated.</p></li><li><p>RAuth app generates 30-Second, long, Base32Encoded Key.</p></li><li><p>User presses "Copy" next to the key and quickly pastes it into the website.</p></li><li><p>Website connects to WebSocket.</p></li><li><p>Website sends key typed in to RAuth app.</p></li><li><p>RAuth app checks first if the website is the one typed in. If not, it returns "Nope" and stops the WebSocket. If yes, it starts what the user configured for authentication.</p></li><li><p>If all configured authentication passes, it sends an "OK" and stops the WebSocket. If any part fails, it sends back "Nope" and stops the WebSocket.</p></li></ol>