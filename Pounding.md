<h1><strong>Documentation: Pounding 3.0 (Total Flexibility Edition)</strong></h1><p></p><p>The <strong>Pounding 3.0</strong> protocol is a non-linear cryptographic hashing pipeline. Its defining characteristic is <strong>Dynamic Input Mapping</strong>, allowing every parameter (Salt, Pounding, Sugar, and IV) to accept either alphanumeric strings or integers. This creates a multi-dimensional security layer where the "key" is not just the password, but the configuration of the engine itself.</p><p></p><hr><h2><strong>1. The Pre-Processing Stage: FlexibleNum</strong></h2><p></p><p>Before the math begins, every input (Password, Salt, Sugar, etc.) passes through the <strong>FlexibleNum</strong> function. This ensures that text strings are converted into mathematical entities.</p><p></p><p>The Formula:</p><p></p><p>For any input string $S$, each character $c$ at position $j$ is processed:</p><p></p><p></p><p></p><p>$$N = \sum_{j=1}^{len(S)} (ASCII(c_j) \times j)$$</p><ul><li><p><strong>Example:</strong> "ABC" becomes $(65 \times 1) + (66 \times 2) + (67 \times 3) = 398$.</p><p></p></li><li><p><strong>Purpose:</strong> This prevents "anagram collisions" and allows the use of words as mathematical constants.</p><p></p></li></ul><p></p><hr><h2><strong>2. The Five-Step Pounding Pipeline</strong></h2><p></p><h3><strong>Step 1: Switchi-Switchi (Initial Scramble)</strong></h3><p></p><p>The Numenized password ($N_{pass}$) and the Salt ($s$) are used to seed a <strong>Fisher-Yates Shuffle</strong>.</p><p></p><ol><li><p>The digits of $N_{pass}$ are placed in a list.</p><p></p></li><li><p><code>math.randomseed(N_{pass} + s)</code> is set.</p><p></p></li><li><p>The digits are shuffled randomly.</p><p></p></li><li><p>The result is a new integer, <strong>Scrambled Value ($S$)</strong>.</p><p></p></li></ol><p></p><h3><strong>Step 2: The Pounding Engine (Key Stretching)</strong></h3><p></p><p>This stage applies exponential growth to the data. To prevent the number from becoming too large for the computer's memory, we use Modular Exponentiation:</p><p></p><p></p><p></p><p>$$R_{pounded} = (S + s)^p \pmod{i}$$</p><ul><li><p><strong>$p$ (Pounding Factor):</strong> Determines how many times the value is multiplied by itself.</p><p></p></li><li><p><strong>$i$ (IV/Modulus):</strong> Determines the "walls" of the math, keeping the result within a specific range.</p><p></p></li></ul><p></p><h3><strong>Step 3: BinaryWiseMath (The Bitwise Layer)</strong></h3><p></p><p>To ensure an "Avalanche Effect" (where changing one letter changes the whole hash), we apply a bitwise XOR ($\oplus$) operation between the result and the Salt:</p><p></p><p></p><p></p><p>$$R_{bitwise} = R_{pounded} \oplus s$$</p><ul><li><p><strong>Logic:</strong> This flips the binary bits (0s and 1s) of the number based on the Salt's binary pattern.</p><p></p></li></ul><p></p><h3><strong>Step 4: The Flattening (Sugar &amp; Compression)</strong></h3><p></p><p>The final shift is applied using the Sugar ($u$) value, and the number is compressed back into the IV range:</p><p></p><p></p><p></p><p>$$R_{final} = |(R_{bitwise} - u) \pmod{i}|$$</p><h3><strong>Step 5: Base32 Alpha-Encoding</strong></h3><p></p><p>The raw integer $R_{final}$ is converted into a professional-grade string using the Base32 alphabet: <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ234567</code>.</p><p></p><ul><li><p>Each digit of the final number is mapped to its corresponding letter.</p><p></p></li><li><p><strong>Example:</strong> If the result is <code>0</code>, it maps to <code>A</code>. If the result is <code>10</code>, it maps to <code>K</code>.</p><p></p></li></ul><p></p><hr><h2><strong>3. Verification &amp; Security Philosophy</strong></h2><p></p><h3><strong>Lossy Transformation</strong></h3><p></p><p>Because of the <strong>Modulo ($i$)</strong> operation, Pounding 3.0 is a "lossy" algorithm. Information is intentionally discarded.</p><p></p><ul><li><p><strong>One-Way Only:</strong> You cannot perform "Un-Pounding."</p><p></p></li><li><p><strong>Verification:</strong> To check a password, the system re-runs the entire pipeline. If the generated <strong>CryptyPound</strong> matches the stored one, the password is correct.</p><p></p></li></ul><p></p><h3><strong>The "Work Factor"</strong></h3><p></p><p>Security in Pounding 3.0 is a choice.</p><p></p><ul><li><p><strong>High Security:</strong> Set $p$ to a high value (e.g., <code>10000</code>) and use long strings for $s$ and $i$.</p><p></p></li><li><p><strong>Low Security:</strong> Set $p = 1$ and $i = 100$.</p><p></p></li></ul><hr><hr><hr><hr><hr>